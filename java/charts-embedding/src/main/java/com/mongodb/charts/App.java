package com.mongodb.charts;

import static spark.Spark.get;
import static spark.Spark.staticFiles;

import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.apache.catalina.util.URLEncoder;


/**
 * A simple web server which returns a signed embedding url for a given chart.
 *
 * Server by default runs on port 4567.
 */
public class App {
  // Replace these constants with the correct values for your Charts instance

  // Replace with the base URL to your Charts instance, e.g.
  // https://charts.mongodb.com/charts-foo-abcde (no trailing slash)
  private final static String CHARTS_EMBEDDING_BASE_URL = "~REPLACE~CHARTS_EMBEDDING_BASE_URL";

  // Replace with the Embedding Signing Key generated by your Charts admin
  private final static String EMBEDDING_SIGNING_KEY = "~REPLACE~EMBEDDING_SIGNING_KEY";

  // Set to your preferred expiry period
  private final static Duration expiryTime = Duration.ofMinutes(5);

  // Set to a MongoDB Query if you want to filter the chart, e.g. "{ foo: { $gt: 10 }}"
  private final static String FILTER_DOCUMENT = null; 

  // Set to a number of seconds >=10 if you want the chart to autorefresh, eg. Duration.ofSeconds(30)
  private final static Duration autoRefreshTime = null; 

  public static void main(String[] args) {
     staticFiles.location("www");

     get("/api/embeddedchart/:id", (request, response) -> {
       response.type("text/plain");
       final String id = request.params(":id");
       return generateSecureUrl(id);
      });
  }

  private static String generateSecureUrl(String id) {
    // Remember, in a real application, you should ensure your user is authenticated
    // and authorized to view the chart before you return the signed URL.

    long timestamp = System.currentTimeMillis() / 1000;

    StringBuilder payload = new StringBuilder()
      .append("id=").append(id)
      .append("&timestamp=").append(timestamp)
      .append("&expires-in=").append(expiryTime.toMillis() / 1000);

      if (FILTER_DOCUMENT != null) {
        // Using URLEncoder as it converts spaces to %20 which is required for the signature to be validated
        payload.append("&filter=").append(new URLEncoder().encode(FILTER_DOCUMENT));
      }
      if (autoRefreshTime != null) {
        payload.append("&autorefresh=").append(autoRefreshTime.getSeconds());
      }

      String signature = generateSignedPayload(EMBEDDING_SIGNING_KEY, payload.toString());
      
      StringBuilder url = new StringBuilder(CHARTS_EMBEDDING_BASE_URL)
        .append("/embed/charts?")
        .append(payload)
        .append("&signature=").append(signature);
      return url.toString();
  }

  private static String generateSignedPayload(String key, String payload) {
    try {
      Mac hasher = Mac.getInstance("HmacSHA256");
      hasher.init(new SecretKeySpec(key.getBytes(), "HmacSHA256"));
      byte[] hashedBytes = hasher.doFinal(payload.getBytes());

      return new BigInteger(1, hashedBytes).toString(16);
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
      throw new RuntimeException("Could not get algorithm for HmacSHA256");

    } catch (InvalidKeyException e) {
      e.printStackTrace();
      throw new RuntimeException("Provided key was invalid, possibly null");
    }
  }
}
